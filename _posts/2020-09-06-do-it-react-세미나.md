---
title: "2020.09.06 do-it-react 세미나"
date: 2020-09-06 20:26:28 -0400
categories: React Javascript Css Scss Sass
---

with 1ilsang && Lee Gi In

## 4장: 에어비앤비 디자인 시스템 따라하기

   - 스토리북: 테스트 할 때 과정이 복잡한게 있는데. 그런 것들은 스토리북에서 해당 컴포넌트를 박아놓으면 최초에 어떤 상태이고 그 상태에서 어떤 뷰다 라는걸 보여줌. 이야기의 흐름에 따라서 인덱스를 바로 넘어가게 해줌! 어떤 action이 일어나는지도 다 관리를 해줌. 언제 떠야되는지 이런거 확인할때 편함.

   - sass scss less: less와 scss의 차이 

     css 는 중첩 구조를 계속 만들어줘야함 (div h1 a 이런식으로) -> 불편

     sass 나 less 는 import 로 바로 걸어서 상속을 해서 a만 작성해 줄 수 있음

     less는 문법이 다름 sass / scss 는 똑같은데 sass 가 먼저 나옴. 제이드나 루비 문법으로 만든게 최초의 sass 컴파일 

     less를 하는 이유: 다이나믹 임포트, 간결한 문법 때메 less

     less 는 전처리기. 배포 자체 dist 파일을 아예 바꿔야 하지는 않음

     - node-sass: scss 파일을 컴파일하여 CSS 파일로 생성
- sass-loader: webpack 에 sass 추가 (리액트랑 따로노는 스토리북이 싸스를 컴파일해서 로딩해야돼서 하는거임. css 는 굳이 cli를 해줘야되니까 웹팩을 리로딩 할때마다 컴파일 알아서 해주라 하기 위해 sass-loader 가 필요)
     
- styled-components : 글로벌 스코프를 더럽히지 않는게 가장 큰 장점

  HOC 로 구성. 화면을 출력하는 시작 순간에 스타일 코드를 같이 출력한다.

  css-in-js 를 안쓰면 같이 내려주는게 아니라 글자가 깜박임

  html 파싱을 보면(참고는 naver D2), head 에서 스타일 링크들을 가져오는데, 추상 트리를 만들고 돔 트리(react라 js)랑 css 트리 두개를 만듦. 컴포넌트 깜박임 현상!!

  렌더링 쳐서 한번에 보여주는건 SSR 은 관계없음.

  CSS-in-JS 자바스크립트가 돔에 붙는게 css 보다 빠름. html 붙고. css 붙고, js 붙고 이런식인데, 이걸 js-css가 붙으면 보여줌. 

  폰트를 axios 로 가져오고, js에서 폰트를 다운받고 있으면 같이 못가져옴

  깜박임 일어날 수도 있다.  

- media 속성값

  반응형 디자인. small: mobile, medium: tablet, large: desktop

  이거 하면 css가 알아서 해줌

  largeAndAboves: 모니터에 특화된 해상도 (해상도에 맞춰서 미디어 태그를 줄 수 있다)

  확장이 됨 styled(Component 명)

  Component 는 클래스형

  PureComponent 는 함수형으로 쓰일때

  



## 2. 리액트 고급 기술 따라하기

- Curring(커링)

인자를 여러개 넣고 하나의 리턴값을 만들어내는데,

커링은 여러개의 인자들을 쪼개고 싶다는게 핵심

지연실행 => 인자 받고 다음 인자 기다리고 마지막 인자 들어왔을때 모두 결합

비슷한데 값은 다른 그런 중복코드가 많을때 유용하게 쓰임

상속이랑 똑같이 함수 하나만 바뀌어도 연관된 애들이 다 바뀔 수 있음

a를 받을 때까지 2를 실행시키는걸 기다리겠다.

비즈니스 로직을 한군데로 몰아넣을 수 있다.



순서가 있고, 중복이 많이 될 만한 코드는 커링을 사용하여 짜는게 좋다?

비즈니스 로직이 들어갈 만 한걸 다 만들어놓으면 안에 내용은 잘 몰라도됨. 수식 내용을 합성해가는 과정.

함수형은 한줄이면 다 됨 => 코드가 짧아짐

커링을 하면서 재활용 할 수 있음 + 코드가 다 쪼개지게됨

모든 함수가 도메인 단위로 감. 사이드 이펙트가 없어야됨. 불변해야함. 누가 사용하든지 간에 결과값은 하나여야함.

커링이 너무 많으면 성능이 나빠질 수 있고 다른 사람들이 코드를 읽는데 어려울 수 있음! 이슈 체크를 해서 메모를 남김



(커링은 HOF 고 styled-component 는 HOC구나)



왜 리액트가 hoc 를 선택했는지 (decorate pattern)

데코레이터 라는 인터페이스를 가지고 있어서 다중상속을 해야하는 경우를 해결

해도 되고 안해도 되는데 이런게 있어~ 이런 느낌



고오급 리액트 기본 

팩토리패턴, 스트레터지, 데코레이터, 커맨트패턴, 추상팩토리패턴(AF)

 => 라이브러리 까볼때. 모든 라이브러리가 이런 패턴을 다 쓰고 있음. 

오픈소스 습득 능력에 차이가 나게됨



## 3. 컨텍스트로 데이터 관리하기

context API



컨스트란? 

스코프랑 거의 비슷한 동의어임. 

글로벌 블록 펑션 3개의 스코프를 벗어난 나만의 스코프를 만드는 느낌



execute context 실행 컨텍스트에 따라서 this의 바인딩이 달라짐

근원적인 이유는 lexical environment

this 가 실행 컨텍스트에 묶이는 순간 문맥적 환경이 그걸 바라봄

컴파일 단위 / 런타임 단위에 따라서 실행 컨텍스트가 달라짐

그래서 Arrow Function이나 this.bind를 통해 묶어준거임



어떠한 값에 스코프를 강제시키겠다는 것

내가 원하는건 사진이 바뀌면 옆 값이 바뀌는거임 (평생관계의 props)

Observalble Pattern 을 사용하여 Provider / Consumer 의 역할을 분리해 데이터를 Subscribe 하도록 한다.

어찌보면 전역 스토어가됨. 특정 값만 땡겨오는것임



루프가 각각의 이벤트 쓰레드를 가지고 있고(큐), 걔넨 각각 스택에 들어감

스택이 빌때까지 루프에 계속 던져줌

큐들이 비었는지 확인하는거. 1초마다 보는건 쓰레드 부하가 일어남

모든 큐들은 Observer Pattern을 통해 que provider를 바라보고 있음

큐는 프로바이더를 섭스크라이브함. 끝날때마다 알려줌

이벤트 루프가 옵저버 패턴을 사용했다!



Provider 어떻게 돌아가는지 알아야함

컴포넌트지만 그리는건 아니고 임명 컴포넌트임



--- 1회차 주요 개념 ---
- Curring
- HOC
- 디자인 패턴 (Strategy, Observer, Decorator, Factory, Abstract)
- Context API
- Observable Pattern
- Provider